{
  "name": "DocumentAll",
  "description": "This component brings together all the components, functions and examples\nfor documentation generation purposes.",
  "props": [],
  "filePath": "examples/DocumentAll.tsx",
  "sourceCode": "import React from 'react';\nimport App from './App';\nimport Todo, { TodoItem as TodoItemType } from './Todo';\nimport TodoItem from './TodoItem';\nimport RecursiveExamples, {\n    factorial,\n    fibonacci as recursiveExamplesFibonacci,\n    sumNestedArray,\n    depthFirstTraversal,\n    RecursiveTreeProcessor,\n    CommentThread,\n    deepClone,\n    traverseDOM,\n    recursivePromiseChain,\n    Comment,\n    TreeNode\n} from './RecursiveExamples';\nimport UseRecursiveExamples from './UseRecursiveExamples';\nimport FibonacciExample, { fibonacci } from './Fibonacci';\nimport HealthcareDashboard, { Patient, MedicalRecord, PatientStatus, Department } from './HealthcareDashboard';\n\n/**\n * This component brings together all the components, functions and examples\n * for documentation generation purposes.\n */\nconst DocumentAll: React.FC = () => {\n    // Create demo data for examples\n    const demoTree: TreeNode<string> = {\n        value: 'root',\n        children: [{ value: 'child', children: [] }]\n    };\n\n    const demoComments: Comment[] = [\n        { id: '1', text: 'Example comment', author: 'User', replies: [] }\n    ];\n\n    // Demo patient for healthcare dashboard\n    const demoPatient: Patient = {\n        id: 'P1001',\n        name: 'John Doe',\n        age: 45,\n        gender: 'male',\n        status: 'admitted',\n        department: 'cardiology',\n        roomNumber: '301',\n        assignedDoctor: 'Dr. Smith',\n        admissionDate: '2023-05-15',\n        expectedDischargeDate: '2023-05-22',\n        diagnosis: 'Hypertension',\n        medicalRecords: [\n            {\n                id: 'REC1001',\n                type: 'lab',\n                date: '2023-05-16',\n                description: 'Comprehensive Metabolic Panel',\n                provider: 'Dr. Johnson',\n                values: [\n                    {\n                        name: 'Glucose',\n                        value: 95,\n                        unit: 'mg/dL',\n                        normalRange: { min: 70, max: 100 }\n                    }\n                ]\n            }\n        ],\n        insurance: {\n            provider: 'Blue Cross',\n            policyNumber: 'BC12345',\n            coveragePercentage: 80\n        },\n        emergencyContact: {\n            name: 'Jane Doe',\n            relationship: 'Spouse',\n            phone: '(555) 123-4567'\n        }\n    };\n\n    // This component is never actually rendered, it just exists to document everything\n    return (\n        <div>\n            <h1>Documentation Components</h1>\n\n            {/* Standard App Components */}\n            <App title=\"Example App\" showRecursiveExamples={true} />\n            <Todo\n                initialTodos={[\n                    {\n                        id: '1',\n                        text: 'Test Todo',\n                        completed: false,\n                        priority: 'high',\n                        category: 'work',\n                        dueDate: '2023-06-30',\n                        createdAt: '2023-06-01'\n                    }\n                ]}\n                onTodoAdded={(todo) => console.log(todo)}\n                title=\"Example Todos\"\n                darkMode={false}\n                enableStorage={true}\n            />\n            <TodoItem\n                todo={{\n                    id: '1',\n                    text: 'Test Todo',\n                    completed: false,\n                    priority: 'high',\n                    category: 'work',\n                    dueDate: '2023-06-30',\n                    createdAt: '2023-06-01'\n                }}\n                onToggle={() => { }}\n                onDelete={() => { }}\n                onUpdatePriority={() => { }}\n                onUpdateCategory={() => { }}\n                onUpdateDueDate={() => { }}\n                onAddNotes={() => { }}\n                categories={['work', 'personal', 'shopping', 'health', 'other']}\n            />\n\n            {/* Healthcare Dashboard Example */}\n            <HealthcareDashboard\n                initialPatients={[demoPatient]}\n                adminMode={true}\n                currentUser=\"Dr. Administrator\"\n                departmentFilter=\"cardiology\"\n                onPatientSelect={(patient) => console.log(`Selected patient: ${patient.id}`)}\n            />\n\n            {/* Recursive Examples */}\n            <RecursiveExamples />\n            <UseRecursiveExamples />\n            <CommentThread comments={demoComments} />\n            <FibonacciExample />\n\n            {/* These would normally be hidden, but included for documentation */}\n            <div style={{ display: 'none' }}>\n                <h2>Recursive Functions (TypeScript)</h2>\n                <p>{`factorial(5) = ${factorial(5)}`}</p>\n\n                {/* Make sure fibonacci is properly documented with explicit implementation */}\n                <div id=\"fibonacci-example\">\n                    <h3>Fibonacci Function</h3>\n                    <p>{`Imported fibonacci(10) = ${fibonacci(10)}`}</p>\n                    <p>{`RecursiveExamples fibonacci(10) = ${recursiveExamplesFibonacci(10)}`}</p>\n                    <pre>\n                        {`\n// Fibonacci calculation with recursion and memoization\nexport function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}\n                        `}\n                    </pre>\n                </div>\n\n                <p>{`sumNestedArray([1, [2, 3]]) = ${sumNestedArray([1, [2, 3]])}`}</p>\n\n                <h2>Hospital Test JavaScript</h2>\n                <div id=\"hospital-examples\">\n                    {(() => {\n                        // Sample patient data\n                        const patient = {\n                            id: 'P1001',\n                            name: 'John Doe',\n                            roomCharge: 500,\n                            procedures: [\n                                { name: 'X-Ray', cost: 250 },\n                                { name: 'Blood Test', cost: 100 }\n                            ],\n                            medications: [\n                                { name: 'Antibiotic', cost: 75 },\n                                { name: 'Pain Reliever', cost: 25 }\n                            ]\n                        };\n\n                        // Sample hospital hierarchy\n                        const hospital = {\n                            type: 'hospital',\n                            name: 'General Hospital',\n                            children: [\n                                {\n                                    type: 'floor',\n                                    name: 'Floor 1',\n                                    children: [\n                                        {\n                                            type: 'room',\n                                            name: 'Room 101',\n                                            children: [\n                                                { type: 'patient', id: 'P1001', name: 'John Doe' }\n                                            ]\n                                        }\n                                    ]\n                                }\n                            ]\n                        };\n\n                        // Sample org chart data\n                        const orgChart = {\n                            name: 'Dr. Smith',\n                            role: 'Chief of Medicine',\n                            subordinates: [\n                                {\n                                    name: 'Dr. Johnson',\n                                    role: 'Head of Surgery',\n                                    subordinates: [\n                                        { name: 'Dr. Williams', role: 'Surgeon', subordinates: [] }\n                                    ]\n                                },\n                                {\n                                    name: 'Dr. Brown',\n                                    role: 'Head of Pediatrics',\n                                    subordinates: []\n                                }\n                            ]\n                        };\n\n                        return (\n                            <>\n                                <h3>Calculate Patient Cost</h3>\n                                <p>{`Patient: ${patient.name}`}</p>\n                                <p>{`Total Cost: $${calculatePatientCost(patient)}`}</p>\n\n                                <h3>Find Patient</h3>\n                                <p>{`Found patient: ${findPatient(hospital, 'P1001')?.name || 'Not found'}`}</p>\n\n                                <h3>Hospital Organization Chart</h3>\n                                <pre>{buildHospitalOrgChart(orgChart)}</pre>\n                            </>\n                        );\n                    })()}\n                </div>\n\n                <h2>Recursive Classes</h2>\n                {(() => {\n                    const processor = new RecursiveTreeProcessor(demoTree);\n                    const mappedTree = processor.mapTree(val => val.toUpperCase());\n                    return <p>Tree processor example</p>;\n                })()}\n\n                <h2>JavaScript Examples</h2>\n                <p>deepClone example</p>\n                <p>traverseDOM example</p>\n                <p>recursivePromiseChain example</p>\n            </div>\n        </div>\n    );\n};\n\n/**\n * Hospital data recursive function examples\n */\n\n/**\n * A recursive function to calculate the total cost of a patient's stay\n * including all procedures, medications, and room charges\n */\nexport function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}\n\n/**\n * Recursive function to find a patient in a hospital hierarchy (floors, wings, rooms)\n */\nexport function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Recursively build a hospital organizational chart\n */\nexport function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}\n\nexport default DocumentAll;\n",
  "childComponents": [],
  "methods": [
    {
      "name": "fibonacci",
      "params": [
        {
          "name": "n",
          "type": "number"
        },
        {
          "name": "memo",
          "type": "Record<number"
        },
        {
          "name": "number> = {}",
          "type": "any"
        }
      ],
      "returnType": "number",
      "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}",
      "similarityWarnings": [
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.9936767154008945,
          "reason": "Function appears to have similar functionality (99% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.9936767154008945,
          "reason": "Function appears to have similar functionality (99% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.8153431375485499,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.8153431375485499,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.8153431375485499,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.8153431375485499,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.8153431375485499,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.8067977364596283,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.753639621731647,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7443492184898798,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7388966650429083,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7364811190299572,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7346062727725517,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "findPatient.calculatePatientCost",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.calculatePatientCost",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.7330342530923258,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.7288672988283411,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.7288672988283411,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.7288672988283411,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.7288672988283411,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.7288672988283411,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7242015939162301,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7187911802846157,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7121582265305647,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7114222429749806,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "calculatePatientCost.if",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "findPatient.if",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "buildHospitalOrgChart.if",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.7046417072937028,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7029763708638274,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7007747642257963,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.7006668556904135,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "calculatePatientCost.for",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.for",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "buildHospitalOrgChart.for",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.6921488587736232,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6909356643375163,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.6849325759738175,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "calculatePatientCost.findPatient",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.findPatient",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.6827866146692592,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.6801493280378237,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.6765847569276644,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.6755761168671692,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.6701496131331041,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.669858645489701,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.6646554851331921,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6621499463045559,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "Todo.handleAddNotes",
          "score": 0.6610602624066834,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddNotes = (id: string, notes: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, notes } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.6610285484340379,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6608059646668806,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6578586870027666,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.6569786334730149,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "calculatePatientCost.buildHospitalOrgChart",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "findPatient.buildHospitalOrgChart",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.6550903089337757,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.6519824643746336,
          "reason": "Function appears to have similar functionality (65% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.6478775702232201,
          "reason": "Function appears to have similar functionality (65% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.64489597595483,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.6429582557247608,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.6427856889572257,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.6402273425604142,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.6394318932459019,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.6390240097933486,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6386480614038008,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.6275203123501196,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "factorial.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "sumNestedArray.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "deepClone.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveTreeProcessor.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "CommentThread.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveExamples.renderComment",
          "score": 0.6048188904948657,
          "reason": "Function appears to have similar functionality (60% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        }
      ]
    },
    {
      "name": "calculatePatientCost",
      "params": [
        {
          "name": "patient",
          "type": "any"
        }
      ],
      "returnType": "number",
      "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}",
      "similarityWarnings": [
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8114697855885966,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "calculatePatientCost.findPatient",
          "score": 0.7968122894947479,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.findPatient",
          "score": 0.7968122894947479,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "calculatePatientCost.for",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.for",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "buildHospitalOrgChart.for",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.7724601446242829,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.7724601446242829,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.7724601446242829,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.7724601446242829,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.7724601446242829,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "calculatePatientCost.if",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "findPatient.if",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "buildHospitalOrgChart.if",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7700357795066096,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7630416898567699,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "calculatePatientCost.buildHospitalOrgChart",
          "score": 0.7459908914991796,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "findPatient.buildHospitalOrgChart",
          "score": 0.7459908914991796,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.7422327026295952,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.7408602363711355,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.7408602363711355,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.7408602363711355,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.7408602363711355,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.7408602363711355,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7371310889981614,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "calculatePatientCost.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "deepClone.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "CommentThread.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveExamples.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "findPatient.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "DocumentAll.fibonacci",
          "score": 0.733780782526374,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7321364062978064,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.7290721553781677,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.7290721553781677,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7284634062714777,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7220824221502872,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7190820668662239,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.7142661016181933,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7117050726553351,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.7055914077767833,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7006389155961136,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.6972152315116377,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.6919056413566822,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.686690563662411,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.6849850743689699,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6818956077927003,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.6814100919027332,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.677848621604003,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.6763939025586807,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.6761336550134827,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6755532374031004,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.6678034441763365,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.6647474341740816,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.6636153975878388,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.658484012881366,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.6528888763757965,
          "reason": "Function appears to have similar functionality (65% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.6468409258005543,
          "reason": "Function appears to have similar functionality (65% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.643618263329078,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.642903166393714,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.6428143786479212,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6411341198755892,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.6406823116373456,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.639887828920384,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.6391889559956017,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.6296097751534249,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.6254172559659119,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.6246297296691901,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.6210773504117206,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.6153582871646196,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        }
      ]
    },
    {
      "name": "findPatient",
      "params": [
        {
          "name": "hospital",
          "type": "any"
        },
        {
          "name": "patientId",
          "type": "string"
        }
      ],
      "returnType": "any",
      "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}",
      "similarityWarnings": [
        {
          "similarTo": "calculatePatientCost.for",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.for",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "buildHospitalOrgChart.for",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "calculatePatientCost.if",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "findPatient.if",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "buildHospitalOrgChart.if",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8153778466157455,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8095993899826436,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7997892678420998,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.calculatePatientCost",
          "score": 0.7968122894947479,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.calculatePatientCost",
          "score": 0.7968122894947479,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "DocumentAll.calculatePatientCost",
          "score": 0.7968122894947479,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7908204776178391,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7685176661473548,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "calculatePatientCost.buildHospitalOrgChart",
          "score": 0.7664497703557939,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "findPatient.buildHospitalOrgChart",
          "score": 0.7664497703557939,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.7616889435826389,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.7588146654200606,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7575491142758187,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7563696888400357,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.755414657298411,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7495847049337491,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7453495718614734,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7434133061870205,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.740798315063348,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.7406114060219362,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.7406114060219362,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.7406114060219362,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.7406114060219362,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.7406114060219362,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7383398348776901,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7375184912965993,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.7314377162284689,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.7285521951428092,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7252446515750078,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.7240174625473678,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7236481285633931,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7227659494708848,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7193331486013476,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.7075487035531843,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.6975876570709696,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.6897868729233368,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.6885634920642805,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "calculatePatientCost.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "deepClone.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "CommentThread.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveExamples.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "findPatient.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "DocumentAll.fibonacci",
          "score": 0.6840577575779809,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.6819023843086419,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.6819023843086419,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.6819023843086419,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.6819023843086419,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.6819023843086419,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6791060986429915,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6791060986429915,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.6756770055584101,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.6675614953631116,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.6674409798527877,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.6656508458272453,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.6632886837546356,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.6579371778256442,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.6499016714304724,
          "reason": "Function appears to have similar functionality (65% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.6405459161098245,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "Todo.handleAddNotes",
          "score": 0.6374959900052832,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddNotes = (id: string, notes: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, notes } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.6356732494954999,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.6299892294288986,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6268184336719129,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.624843934134741,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.6117397782781745,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.6089953081375107,
          "reason": "Function appears to have similar functionality (61% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        }
      ]
    },
    {
      "name": "if",
      "params": [
        {
          "name": "hospital.type === 'patient' && hospital.id === patientId",
          "type": "any"
        }
      ],
      "returnType": "void",
      "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }",
      "similarityWarnings": [
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.9035306797425809,
          "reason": "Function appears to have similar functionality (90% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "calculatePatientCost.for",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.for",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "buildHospitalOrgChart.for",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8681115119530848,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8676755732690085,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.867198331883805,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8633791640213466,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.8630942857758426,
          "reason": "Function appears to have similar functionality (86% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "calculatePatientCost.findPatient",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.findPatient",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "DocumentAll.findPatient",
          "score": 0.8498360315518491,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.8391388180759939,
          "reason": "Function appears to have similar functionality (84% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.8262353718464167,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.823800395977576,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.8169967094742822,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.8122099279164414,
          "reason": "Function appears to have similar functionality (81% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.8023366712798435,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.7836140383789663,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.7770881306320824,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7748487801497511,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.773902386191897,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.772824064261289,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7716469001391171,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "findPatient.calculatePatientCost",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.calculatePatientCost",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "DocumentAll.calculatePatientCost",
          "score": 0.7707255507521131,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7622540002924695,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.7541194282360371,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.752305349567527,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.7460030872022815,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.7456091510350097,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7454011341058312,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.7419124095381487,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "calculatePatientCost.buildHospitalOrgChart",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "findPatient.buildHospitalOrgChart",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7371533795805081,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.734207277811796,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.7291366106079232,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.7232716416423449,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.7232716416423449,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.7232716416423449,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.7232716416423449,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.7232716416423449,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.7205429278203181,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.7127154931360195,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.7109455207793259,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.709428080686487,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.709428080686487,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.709428080686487,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.709428080686487,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.709428080686487,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "calculatePatientCost.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "deepClone.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "CommentThread.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveExamples.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "findPatient.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "DocumentAll.fibonacci",
          "score": 0.7090007745876641,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Todo.handleAddNotes",
          "score": 0.7055334150102949,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddNotes = (id: string, notes: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, notes } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6936288651601552,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6936288651601552,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.6928029581827734,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.6878870020556984,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.6850329969103433,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6850145020503027,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.6839903261497279,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.6794482328472733,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.664420190513949,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.6574758521048489,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "factorial.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "sumNestedArray.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "deepClone.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveTreeProcessor.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "CommentThread.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveExamples.renderComment",
          "score": 0.6558668770781725,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.6374196224066616,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.623898241630341,
          "reason": "Function appears to have similar functionality (62% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        }
      ]
    },
    {
      "name": "for",
      "params": [
        {
          "name": "child of hospital.children",
          "type": "any"
        }
      ],
      "returnType": "void",
      "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }",
      "similarityWarnings": [
        {
          "similarTo": "factorial.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.9100408143103078,
          "reason": "Function appears to have similar functionality (91% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "calculatePatientCost.if",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "findPatient.if",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "buildHospitalOrgChart.if",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "DocumentAll.if",
          "score": 0.8872713905659667,
          "reason": "Function appears to have similar functionality (89% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.8846790514068484,
          "reason": "Function appears to have similar functionality (88% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "calculatePatientCost.findPatient",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.findPatient",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "DocumentAll.findPatient",
          "score": 0.8718121677092725,
          "reason": "Function appears to have similar functionality (87% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8525774455095052,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8483218589482737,
          "reason": "Function appears to have similar functionality (85% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.841624126114039,
          "reason": "Function appears to have similar functionality (84% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.8282278374991462,
          "reason": "Function appears to have similar functionality (83% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.8185774963260363,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.8171222741239181,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.8152953948330788,
          "reason": "Function appears to have similar functionality (82% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.8048487229945663,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.8014037045418478,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.797835553249666,
          "reason": "Function appears to have similar functionality (80% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7938408779708314,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.7900580461644321,
          "reason": "Function appears to have similar functionality (79% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7813274527549386,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.7807670205218129,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "findPatient.calculatePatientCost",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.calculatePatientCost",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "DocumentAll.calculatePatientCost",
          "score": 0.7799499419220985,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7751739165867109,
          "reason": "Function appears to have similar functionality (78% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7727156387722378,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7662569410619819,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7644192829838371,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.7606696682520175,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.7587590385676977,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "calculatePatientCost.buildHospitalOrgChart",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "findPatient.buildHospitalOrgChart",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7476012288245001,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.7403172082263607,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.7344064500180546,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.7337901090032467,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.7249526760825332,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.7249526760825332,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.7249526760825332,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.7249526760825332,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.7249526760825332,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.7215566685086777,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.7214950003835775,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.7211495412348287,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.7190028662133026,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.7121863487930898,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.7121863487930898,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.7121863487930898,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.7121863487930898,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.7121863487930898,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.7034635950748818,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.7023339895037172,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.6994901915887952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "Todo.handleAddNotes",
          "score": 0.6985040754801718,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddNotes = (id: string, notes: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, notes } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.6967304471124952,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "calculatePatientCost.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "deepClone.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "CommentThread.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveExamples.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "findPatient.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "DocumentAll.fibonacci",
          "score": 0.6956737654351405,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.6953214166397821,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.6932319529641631,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "sumNestedArray.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "deepClone.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveTreeProcessor.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "CommentThread.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveExamples.renderComment",
          "score": 0.6897263715307208,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.6888484367721514,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6879583311277475,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.6873262965091594,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.683143324216927,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.683143324216927,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.6640123263764874,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.660924396269221,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        }
      ]
    },
    {
      "name": "buildHospitalOrgChart",
      "params": [
        {
          "name": "department",
          "type": "any"
        }
      ],
      "returnType": "string",
      "code": "function buildHospitalOrgChart(department: any): string {\n    let chart = `${department.name} (${department.role})\\n`;\n\n    if (department.subordinates && Array.isArray(department.subordinates)) {\n        department.subordinates.forEach((staff: any) => {\n            // Recursive call with indentation for each level\n            const subChart = buildHospitalOrgChart(staff)\n                .split('\\n')\n                .map(line => `  ${line}`)\n                .join('\\n');\n            chart += `${subChart}\\n`;\n        });\n    }\n\n    return chart.trim();\n}",
      "similarityWarnings": [
        {
          "similarTo": "calculatePatientCost.findPatient",
          "score": 0.7664497703557939,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.findPatient",
          "score": 0.7664497703557939,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "DocumentAll.findPatient",
          "score": 0.7664497703557939,
          "reason": "Function appears to have similar functionality (77% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function findPatient(hospital: any, patientId: string): any {\n    // Base case - if this is a patient object\n    if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }\n\n    // If this is a floor, wing, or room with children\n    if (hospital.children && Array.isArray(hospital.children)) {\n        for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }\n    }\n\n    return null;\n}"
        },
        {
          "similarTo": "calculatePatientCost.for",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "findPatient.for",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "buildHospitalOrgChart.for",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "DocumentAll.for",
          "score": 0.7560792716544408,
          "reason": "Function appears to have similar functionality (76% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "for (const child of hospital.children) {\n            const result = findPatient(child, patientId);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "factorial.sumNestedArray",
          "score": 0.7501346835645263,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "deepClone.sumNestedArray",
          "score": 0.7501346835645263,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.sumNestedArray",
          "score": 0.7501346835645263,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "CommentThread.sumNestedArray",
          "score": 0.7501346835645263,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "RecursiveExamples.sumNestedArray",
          "score": 0.7501346835645263,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function sumNestedArray(arr: any[]): number {\n    let sum = 0;\n\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }\n\n    return sum;\n}"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7475705901556372,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const item of arr) {\n        if (Array.isArray(item)) {\n            // Recursion within recursion - we recursively process nested arrays\n            sum += sumNestedArray(item);\n        } else if (typeof item === 'number') {\n            sum += item;\n        }\n    }"
        },
        {
          "similarTo": "findPatient.calculatePatientCost",
          "score": 0.7459908914991796,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.calculatePatientCost",
          "score": 0.7459908914991796,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "DocumentAll.calculatePatientCost",
          "score": 0.7459908914991796,
          "reason": "Function appears to have similar functionality (75% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function calculatePatientCost(patient: any): number {\n    let totalCost = patient.roomCharge || 0;\n\n    // Add procedure costs\n    if (patient.procedures && Array.isArray(patient.procedures)) {\n        totalCost += patient.procedures.reduce((acc: number, proc: any) =>\n            acc + proc.cost, 0);\n    }\n\n    // Add medication costs\n    if (patient.medications && Array.isArray(patient.medications)) {\n        totalCost += patient.medications.reduce((acc: number, med: any) =>\n            acc + med.cost, 0);\n    }\n\n    return totalCost;\n}"
        },
        {
          "similarTo": "calculatePatientCost.if",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "findPatient.if",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "buildHospitalOrgChart.if",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "DocumentAll.if",
          "score": 0.7403637830478743,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "if (hospital.type === 'patient' && hospital.id === patientId) {\n        return hospital;\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7399486355780287,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7373110055649494,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage) {\n            const storedTodos = localStorage.getItem('todos');\n            if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            } else {\n                setTodos(initialTodos);\n            }\n        }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7363959808453021,
          "reason": "Function appears to have similar functionality (74% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = deepClone((obj as Record<string, any>)[key]);\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7345424031374134,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (initialPatients.length === 0) {\n            const mockPatients: Patient[] = [];\n            for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }\n            setPatients(mockPatients);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7321088312633592,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.726814542347334,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.725889331826495,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (storedTodos) {\n                setTodos(JSON.parse(storedTodos));\n            }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7258500894029529,
          "reason": "Function appears to have similar functionality (73% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (enableStorage && todos.length > 0) {\n            localStorage.setItem('todos', JSON.stringify(todos));\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.getRandomDescription",
          "score": 0.7198168983211366,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const getRandomDescription = (type: MedicalRecord['type']): string => {\n    const descriptions: Record<MedicalRecord['type'], string[]> = {\n        lab: ['Complete Blood Count', 'Metabolic Panel', 'Lipid Panel', 'Thyroid Function', 'Urinalysis'],\n        visit: ['Annual Checkup', 'Follow-up Appointment', 'Emergency Visit', 'Specialist Consultation'],\n        procedure: ['X-Ray', 'MRI', 'CT Scan', 'Ultrasound', 'Surgery', 'Biopsy'],\n        medication: ['Prescription Update', 'Medication Review', 'New Prescription'],\n        allergy: ['Allergy Test', 'New Allergy Documented', 'Allergy Review'],\n        note: ['Progress Note', 'Doctor\\'s Note', 'Nursing Note', 'Therapy Note']\n    };\n\n    return descriptions[type][Math.floor(Math.random() * descriptions[type].length)];\n}"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.7192221093074301,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }"
        },
        {
          "similarTo": "factorial.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "sumNestedArray.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "deepClone.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "CommentThread.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.for",
          "score": 0.7186684581736398,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "for (const child of node.children) {\n        depthFirstTraversal(child, callback);\n    }"
        },
        {
          "similarTo": "Todo.if",
          "score": 0.7170434491511634,
          "reason": "Function appears to have similar functionality (72% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoCategory",
          "score": 0.7142943167939643,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoCategory = (id: string, category: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, category } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "sumNestedArray.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "deepClone.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "CommentThread.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "RecursiveExamples.forEach",
          "score": 0.7126589361776408,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "forEach(child => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            traverseDOM(child as Element, callback);\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleStatusUpdate",
          "score": 0.7109425702328956,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleStatusUpdate = (patientId: string, newStatus: PatientStatus) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? { ...p, status: newStatus } : p\n        ));\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.if",
          "score": 0.7076575833220401,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "if (onPatientSelect) {\n            onPatientSelect(patient);\n        }"
        },
        {
          "similarTo": "Todo.handleUpdateTodoDueDate",
          "score": 0.7067535464211755,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoDueDate = (id: string, dueDate: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, dueDate } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7060796486637402,
          "reason": "Function appears to have similar functionality (71% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (typeof item === 'number') {\n            sum += item;\n        }"
        },
        {
          "similarTo": "HealthcareDashboard.handleAddMedicalRecord",
          "score": 0.7028803817947044,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handleAddMedicalRecord = (patientId: string, record: MedicalRecord) => {\n        setPatients(patients.map(p =>\n            p.id === patientId ? {\n                ...p,\n                medicalRecords: [...p.medicalRecords, record]\n            } : p\n        ));\n    }"
        },
        {
          "similarTo": "TodoItem.isOverdue",
          "score": 0.7013160075675071,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const isOverdue = () => {\n        if (!todo.dueDate || todo.completed) return false;\n        return new Date(todo.dueDate) < new Date();\n    }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.7011525212630815,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }"
        },
        {
          "similarTo": "Todo.handleAddTodo",
          "score": 0.6954971053319593,
          "reason": "Function appears to have similar functionality (70% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddTodo = () => {\n        if (!newTodoText.trim()) return;\n\n        const newTodo: TodoItem = {\n            id: Date.now().toString(),\n            text: newTodoText,\n            completed: false,\n            category: newTodoCategory,\n            priority: newTodoPriority,\n            dueDate: newTodoDueDate || undefined,\n            createdAt: new Date().toISOString()\n        };\n\n        setTodos([...todos, newTodo]);\n        setNewTodoText('');\n\n        if (onTodoAdded) {\n            onTodoAdded(newTodo);\n        }\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.for",
          "score": 0.6944921234738985,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "for (let i = 0; i < 20; i++) {\n                mockPatients.push(generateMockPatient(`P-${1000 + i}`));\n            }"
        },
        {
          "similarTo": "factorial.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "sumNestedArray.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "deepClone.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "CommentThread.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "RecursiveExamples.if",
          "score": 0.6936394957378221,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "if (index >= actions.length) {\n        return Promise.resolve();\n    }"
        },
        {
          "similarTo": "Todo.handleAddNotes",
          "score": 0.6876624351320573,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleAddNotes = (id: string, notes: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, notes } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.generateMockMedicalRecords",
          "score": 0.6875848465108556,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const generateMockMedicalRecords = (): MedicalRecord[] => {\n    const recordCount = Math.floor(Math.random() * 5) + 1;\n    const records: MedicalRecord[] = [];\n\n    for (let i = 0; i < recordCount; i++) {\n        const recordDate = new Date();\n        recordDate.setDate(recordDate.getDate() - Math.floor(Math.random() * 30));\n\n        const recordType = ['lab', 'visit', 'procedure', 'medication', 'allergy', 'note'][Math.floor(Math.random() * 6)] as MedicalRecord['type'];\n\n        const record: MedicalRecord = {\n            id: `REC-${Math.floor(Math.random() * 1000000)}`,\n            type: recordType,\n            date: recordDate.toISOString().split('T')[0],\n            description: getRandomDescription(recordType),\n            provider: MOCK_DOCTORS[Math.floor(Math.random() * MOCK_DOCTORS.length)],\n        };\n\n        // Add type-specific data\n        if (recordType === 'lab') {\n            record.values = [\n                {\n                    name: 'Glucose',\n                    value: Math.floor(Math.random() * 150) + 70,\n                    unit: 'mg/dL',\n                    normalRange: { min: 70, max: 100 }\n                },\n                {\n                    name: 'Cholesterol',\n                    value: Math.floor(Math.random() * 150) + 120,\n                    unit: 'mg/dL',\n                    normalRange: { min: 125, max: 200 }\n                }\n            ];\n        } else if (recordType === 'procedure') {\n            record.results = ['Successful', 'Completed with complications', 'Rescheduled', 'Completed'][Math.floor(Math.random() * 4)];\n        }\n\n        records.push(record);\n    }\n\n    return records;\n}"
        },
        {
          "similarTo": "Todo.handleUpdateTodoPriority",
          "score": 0.685849502229598,
          "reason": "Function appears to have similar functionality (69% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleUpdateTodoPriority = (id: string, priority: 'low' | 'medium' | 'high') => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, priority } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "Todo.handleToggleTodo",
          "score": 0.6844951695390067,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleToggleTodo = (id: string) => {\n        setTodos(\n            todos.map(todo =>\n                todo.id === id ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    }"
        },
        {
          "similarTo": "factorial.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "sumNestedArray.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "deepClone.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "CommentThread.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.constructor",
          "score": 0.683391346145776,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "constructor(root: TreeNode<T>) {\n        this.root = root;\n    }"
        },
        {
          "similarTo": "Todo.handleDeleteTodo",
          "score": 0.6826400942756132,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/Todo.tsx",
          "code": "const handleDeleteTodo = (id: string) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n    }"
        },
        {
          "similarTo": "factorial.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "sumNestedArray.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "deepClone.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "CommentThread.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "RecursiveExamples.recursivePromiseChain",
          "score": 0.6796636167969574,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function recursivePromiseChain(actions: (() => Promise<any>)[], index = 0): Promise<void> {"
        },
        {
          "similarTo": "App.handleTodoAdded",
          "score": 0.6785060795214752,
          "reason": "Function appears to have similar functionality (68% similar)",
          "filePath": "examples/App.tsx",
          "code": "const handleTodoAdded = (todo: TodoItem) => {\n        setTodos([...todos, todo]);\n    }"
        },
        {
          "similarTo": "TodoItem.handleNotesUpdate",
          "score": 0.674657251703055,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const handleNotesUpdate = () => {\n        onAddNotes(notes);\n        setIsExpanded(false);\n    }"
        },
        {
          "similarTo": "TodoItem.formatDate",
          "score": 0.671850561596143,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/TodoItem.tsx",
          "code": "const formatDate = (dateString?: string) => {\n        if (!dateString) return 'No due date';\n        const date = new Date(dateString);\n        return date.toLocaleDateString();\n    }"
        },
        {
          "similarTo": "factorial.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "sumNestedArray.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "deepClone.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "CommentThread.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.runRecursiveExample",
          "score": 0.6696125053538209,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const runRecursiveExample = () => {\n        // Calculate factorial of 5\n        const fact5 = factorial(5);\n\n        // Calculate 10th Fibonacci number\n        const fib10 = fibonacci(10);\n\n        // Sum the nested array\n        const sum = sumNestedArray(nestedArray);\n\n        // Process the tree\n        const treeProcessor = new RecursiveTreeProcessor(sampleTree);\n        const values: string[] = [];\n        depthFirstTraversal(sampleTree, (val) => values.push(val));\n\n        setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}\n      Sum of nested array: ${sum}\n      Tree values: ${values.join(', ')}\n    `);\n    }"
        },
        {
          "similarTo": "HealthcareDashboard.handlePatientSelect",
          "score": 0.6671287914980872,
          "reason": "Function appears to have similar functionality (67% similar)",
          "filePath": "examples/HealthcareDashboard.tsx",
          "code": "const handlePatientSelect = (patient: Patient) => {\n        setSelectedPatient(patient);\n        if (onPatientSelect) {\n            onPatientSelect(patient);\n        }\n    }"
        },
        {
          "similarTo": "sumNestedArray.factorial",
          "score": 0.6605886511727638,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "deepClone.factorial",
          "score": 0.6605886511727638,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.factorial",
          "score": 0.6605886511727638,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "CommentThread.factorial",
          "score": 0.6605886511727638,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "RecursiveExamples.factorial",
          "score": 0.6605886511727638,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function factorial(n: number): number {\n    // Base case\n    if (n <= 1) return 1;\n    // Recursive case\n    return n * factorial(n - 1);\n}"
        },
        {
          "similarTo": "UseRecursiveExamples.testPromiseChain",
          "score": 0.6577029133380781,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/UseRecursiveExamples.tsx",
          "code": "async function\n    testPromiseChain().catch(err => console.error('Error in promise chain:', err));"
        },
        {
          "similarTo": "factorial.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "sumNestedArray.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "deepClone.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveTreeProcessor.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "CommentThread.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "RecursiveExamples.traverseDOM",
          "score": 0.6571588460843557,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function traverseDOM(element: Element, callback: (el: Element) => void): void {"
        },
        {
          "similarTo": "calculatePatientCost.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "sumNestedArray.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "deepClone.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "CommentThread.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "RecursiveExamples.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "findPatient.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "buildHospitalOrgChart.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "DocumentAll.fibonacci",
          "score": 0.6569147673276075,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/DocumentAll.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6566191106146329,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "Fibonacci.fibonacci",
          "score": 0.6566191106146329,
          "reason": "Function appears to have similar functionality (66% similar)",
          "filePath": "examples/Fibonacci.tsx",
          "code": "function fibonacci(n: number, memo: Record<number, number> = {}): number {\n    // Base cases\n    if (n in memo) return memo[n];\n    if (n <= 1) return n;\n\n    // Recursive case with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}"
        },
        {
          "similarTo": "factorial.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "deepClone.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeByValue",
          "score": 0.6418231757924514,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeByValue(value: T): TreeNode<T> | null {\n        return this.findNodeRecursive(this.root, value);\n    }"
        },
        {
          "similarTo": "factorial.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "sumNestedArray.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "deepClone.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveTreeProcessor.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "CommentThread.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "RecursiveExamples.renderComment",
          "score": 0.6381886573450434,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "const renderComment = (comment: Comment) => ("
        },
        {
          "similarTo": "factorial.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "sumNestedArray.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "deepClone.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveTreeProcessor.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "CommentThread.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "RecursiveExamples.findNodeRecursive",
          "score": 0.6378304185924444,
          "reason": "Function appears to have similar functionality (64% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "findNodeRecursive(node: TreeNode<T>, value: T): TreeNode<T> | null {\n        // Base case - found the node\n        if (node.value === value) return node;\n\n        // Recursive case - search in children\n        for (const child of node.children) {\n            const result = this.findNodeRecursive(child, value);\n            if (result) return result;\n        }\n\n        return null;\n    }"
        },
        {
          "similarTo": "factorial.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "sumNestedArray.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "deepClone.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveTreeProcessor.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "CommentThread.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        },
        {
          "similarTo": "RecursiveExamples.setResult",
          "score": 0.6311620661041384,
          "reason": "Function appears to have similar functionality (63% similar)",
          "filePath": "examples/RecursiveExamples.tsx",
          "code": "setResult(`\n      Factorial of 5: ${fact5}\n      Fibonacci(10): ${fib10}"
        }
      ]
    }
  ],
  "slug": "documentall"
}
